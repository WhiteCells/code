#include "../../head_file.h"

/*
problme: 137. 只出现一次的数字 II

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

示例 1：

输入：nums = [2,2,3,2]
输出：3

示例 2：

输入：nums = [0,1,0,1,0,1,99]
输出：99

提示：

    1 <= nums.length <= 3 * 104
    -231 <= nums[i] <= 231 - 1
    nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次

url: https://leetcode.cn/problems/single-number-ii/description/
 */

// time complexity: O(n)
// spatial complexity: O(1)
// 出现次数恰好为 3 的数, 每一个数的二进制位出现 0 和 1 的次数都为 3 的倍数, 每一位二进制分别累加, 再 %3, 二进制位全为 0
// 出现次数仅为 1 的数, 将所有数的二进制位分别累加, 对每一位进行 %3, 将结果转为十进制, 即为仅出现 1 次的数

// 2 2 2 3 4 4 4
// 0010 (2)
// 0010 (2)
// 0010 (2)
// 0011 (3)
// 0100 (4)
// 0100 (4)
// 0100 (4)
// 每一位二进制相加
// 0341
// 每一位 % 3
// 0011 (3)

// 获取十进制 num 的第 i 位二进制位
// num & (1 << i) // 这种方法没有考虑符号位
// 1 & (num >> i)


// 将十进制 num 的第 i 位二进制变为 1
// num |= (1 << i)

class Solution {
public:
    int singleNumber(vector<int> &nums) {
        int res = 0;
        for (int i = 0; i < 32; ++i) { // 题目范围: -2^31 <= nums[i] <= 2^31 - 1
            int cnt = 0; // 统计每一个数的第 i 位二进制为 1 的个数
            for (const auto &num : nums) {
                // cnt += num & (1 << i); // 数据范围错误
                cnt += (num >> i) & 1;
            }
            res |= cnt % 3 ? (1 << i) : 0; // 如果第 i 位二进制为 1 的个数不为 3 的倍数, 则 res 第 i 位二进制变为 1
        }
        return res;
    }
};

/*
根据题目所给的范围 -2^31 <= nums[i] <= 2^31 - 1，其中 nums[i] 是一个有符号整数。
当使用 num & (1 << i) 来判断第 i 位是否为 1 时，可能会出现问题。
在 C++ 中，有符号整数的右移操作（如 num >> i）是带符号的右移，即如果 num 是负数，则右移后高位会用符号位填充。
这样，在 (num >> i) & 1 这个表达式中，如果 num 是负数且第 i 位为 1，那么右移后的结果将不是 0，而是一个非零的负数（使用补码表示）。
而 (num & (1 << i)) 则没有考虑符号位，直接操作的是原始二进制位，无论正负数都能正确判断第 i 位是否为 1。
 */

int main() {
    vector<int> nums { 0, 1, 0, 1, 0, 1, 99 };
    cout << Solution().singleNumber(nums) << '\n';
    return 0;
}